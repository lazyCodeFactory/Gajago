/**<pre>
 * 1. Project Name : Gapping1.0
 * 2. Package Name : com.lottecard.mall.cmmn.util
 * 3. File Name    : StringUtil.java
 * 4. Date         : 2014. 8. 11. 오후 1:45:55
 * 5. Author       : adrra
 * 6. Note         : 
 * </pre>
 */
package com.ssocio.sharing.cmmn.util;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StringUtil {

	// --------------------------------------------------------------------------
	// # Log 설정
	// --------------------------------------------------------------------------
	private static final Logger logger = LoggerFactory.getLogger(StringUtil.class);
	
	//	네이버 스마트 에디트에서 입력값 없을 시 db에 인서트 되는 값.
	public static final String PROD_DTL_EMPTY_TEXT = "<p>&nbsp;</p>";

	/**
	 * 
	 * @param src
	 * @param width
	 * @return
	 */
	public static String format(short src, int width) {
		return format(src, width, '0', false);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @return
	 */
	public static String format(short src, int width, char fillChar, boolean leftJustify) {
		byte[] b = Short.toString(src).getBytes();
		return format(b, width, fillChar, leftJustify);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @return
	 */
	public static String format(int src, int width) {
		return format(src, width, '0', false);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @return
	 */
	public static String format(int src, int width, char fillChar, boolean leftJustify) {
		byte[] b = Integer.toString(src).getBytes();
		return format(b, width, fillChar, leftJustify);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @return
	 */
	public static String format(long src, int width) {
		return format(src, width, '0', false);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @return
	 */
	public static String format(long src, int width, char fillChar, boolean leftJustify) {
		byte[] b = Long.toString(src).getBytes();
		return format(b, width, fillChar, leftJustify);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @return
	 */
	public static String format(float src, int width) {
		return format(src, width, '0', false);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @return
	 */
	public static String format(float src, int width, char fillChar, boolean leftJustify) {
		byte[] b = Float.toString(src).getBytes();
		return format(b, width, fillChar, leftJustify);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @return
	 */
	public static String format(double src, int width) {
		return format(src, width, '0', false);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @return
	 */
	public static String format(double src, int width, char fillChar, boolean leftJustify) {
		byte[] b = Double.toString(src).getBytes();
		return format(b, width, fillChar, leftJustify);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @return
	 */
	public static String format(String src, int width) {
		return format(src, width, ' ', true);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param charset
	 * @return
	 * @throws UnsupportedEncodingException
	 */
	public static String format(String src, int width, String charset) throws UnsupportedEncodingException {
		return format(src, width, ' ', true, charset);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @return
	 */
	public static String format(String src, int width, char fillChar, boolean leftJustify) {
		byte[] b = null;
		if (src!=null)
			b = src.getBytes();
		return format(b, width, fillChar, leftJustify);
	}
	
	/**
	 * 
	 * @param src
	 * @param width
	 * @param fillChar
	 * @param leftJustify
	 * @param charset
	 * @return
	 * @throws UnsupportedEncodingException
	 */
	public static String format(String src, int width, char fillChar, boolean leftJustify, String charset) throws UnsupportedEncodingException {
		byte[] b = null;
		if (src!=null)
			b = src.getBytes(charset);
		return format(b, width, fillChar, leftJustify, charset);
	}
	
	/**
	 * 주어진 문자열을 포맷팅하여 반환합니다.
	 * 
	 * @param src  원본 문자열의 바이트 배열.
	 * @param width  포맷팅하고자 하는 결과 문자열의 길이.
	 * @param fillChar  공백을 채울 문자.
	 * @param leftJustify  왼쪽으로 맞출 것인지.
	 * @return  결과 문자열.
	 */
	public static String format(byte[] src, int width, char fillChar, boolean leftJustify) {
		int i, j;
		byte[] b = new byte[width];
		if (src == null) {
			for (i = 0; i < width; i++) {
				b[i] = (byte)fillChar;
			}
		} else {
			if (leftJustify == true) {
				for (i = 0, j = 0; i < width; i++) {
					if (i < src.length) {
						b[i] = src[j++];
					} else {
						b[i] = (byte)fillChar;
					}
				}
			} else {
				for (i = 0, j = 0; i < width; i++) {
					if (i < width - src.length) {
						b[i] = (byte)fillChar;
					} else {
						b[i] = src[j++];
					}
				}
			}
		}
		return new String(b);
	}
	
	/**
	 * 주어진 문자열을 포맷팅하여 반환합니다.
	 * 
	 * @param src  원본 문자열의 바이트 배열.
	 * @param width  포맷팅하고자 하는 결과 문자열의 길이.
	 * @param fillChar  공백을 채울 문자.
	 * @param leftJustify  왼쪽으로 맞출 것인지.
	 * @param charset  인코딩하고자 하는 문자셋.
	 * @return  결과 문자열.
	 * @throws UnsupportedEncodingException 문자셋이 지원되지 않을 경우.
	 */
	public static String format(byte[] src, int width, char fillChar, boolean leftJustify, String charset) throws UnsupportedEncodingException {
		int i, j;
		byte[] b = new byte[width];
		if (src == null) {
			for (i = 0; i < width; i++) {
				b[i] = (byte)fillChar;
			}
		} else {
			if (leftJustify == true) {
				for (i = 0, j = 0; i < width; i++) {
					if (i < src.length) {
						b[i] = src[j++];
					} else {
						b[i] = (byte)fillChar;
					}
				}
			} else {
				for (i = 0, j = 0; i < width; i++) {
					if (i < width - src.length) {
						b[i] = (byte)fillChar;
					} else {
						b[i] = src[j++];
					}
				}
			}
		}
		return new String(b, 0, b.length, charset);
	}
	
	/**
	 * String에서 주어진 길이 이상은 잘라낸다. 
	 * 한글이 중간에 잘린경우 해당 한글도 잘라낸다.
	 *  
	 * @param src
	 * @param size
	 * @return
	 */
	public static String trimHan(String src, int size) {
		if (src==null || size <=0 ) return "";
		
		byte[] srcBytes = src.getBytes();
		int len = srcBytes.length;
		
		if (size>=len) return src;
		
		byte[] dstBytes = new byte[size];
		
		int hanCnt=0;
		for (int i=0; i < size; i++) {
			dstBytes[i] = srcBytes[i];
			if ((dstBytes[i]&0xFF) > 0x7F) hanCnt++;
		}
		
		if (((hanCnt%2)!=0) && ((dstBytes[size-1]&0xFF)> 0x7F)) size--;
		
		return new String(dstBytes, 0, size);
	}
	
	/**
	 * XSS 관련 스크립트를 제거한다. 
	 *  
	 * @param src
	 * @return
	 */
	public static String trimXss(String src) {
		if (src==null || src.length()==0 ) return "";
		//src = src.replaceAll("&","&amp;").replaceAll(">", "&gt;").replaceAll("<", "&lt;");
		src = src.replaceAll("<script","&lt;script;").replaceAll("<object", "&lt;object").replaceAll("<embed", "&lt;embed");
		return src;
	}
	
	/**
	 * 
	 * @param b
	 * @param off
	 * @param len
	 * @return
	 */
	public static String dump(byte[] b, int off, int len) {
		
		StringBuffer sb = new StringBuffer();
		int line = len / 16 + 1;
		String s;
		for (int i = 0; i < line; i++) {
			sb.append(format(Integer.toHexString(i*16), 8, '0', false));
			sb.append(' ');
			for (int j = 0; j < 8; j++) {
				int k = i*16 + j*2;
				if (k < len) {
					s = Integer.toHexString((int)b[off+k+0]&0xff);
					sb.append(format(s, 2, '0', false));
				} else {
					sb.append("00");
				}
				if (k+1 < len) {
					s = Integer.toHexString((int)b[off+k+1]&0xff);
					sb.append(format(s, 2, '0', false));
				} else {
					sb.append("00");
				}
				sb.append(' ');
			}
			sb.append(' ');
			StringBuffer sb2 = new StringBuffer();
			for (int j = 0; j < 16; j++) {
				int k = i*16 + j;
				if (k < len) {
					char c = (char)((int)b[off+k]&0xff);
					if (c < 0x20) {
						sb2.append('.');
					} else {
						sb2.append(c);
					}
				} else {
					sb2.append('.');
				}
			}
			s = sb2.toString();
			sb.append(s);
			sb.append('\n');
		}
		sb.append(len);
		sb.append('\n');
		return sb.toString();
	}
	
	/**
	 * 16진수값으로 바이트 배열을 출력합니다.
	 * 
	 * @param b  바이트 배열.
	 * @param off  바이트 배열의 시작옵셋.
	 * @param len  시작옵셋으로부터의 길이.
	 * @param charset  인코딩할 문자셋.
	 * @return  16진수 형식으로 포맷팅된 문자열.
	 * @throws UnsupportedEncodingException 지원되지 않는 문자셋을 사용할 경우.
	 */
	public static String dump(byte[] b, int off, int len, String charset) throws UnsupportedEncodingException {
		StringBuffer sb = new StringBuffer();
		int line = len / 16 + 1;
		String s;
		for (int i = 0; i < line; i++) {
			sb.append(format(Integer.toHexString(i*16), 8, '0', false));
			sb.append(' ');
			for (int j = 0; j < 8; j++) {
				int k = i*16 + j*2;
				if (k < len) {
					s = Integer.toHexString((int)b[off+k+0]&0xff);
					sb.append(format(s, 2, '0', false));
				} else {
					sb.append("00");
				}
				if (k+1 < len) {
					s = Integer.toHexString((int)b[off+k+1]&0xff);
					sb.append(format(s, 2, '0', false));
				} else {
					sb.append("00");
				}
				sb.append(' ');
			}
			sb.append(' ');
			StringBuffer sb2 = new StringBuffer();
			for (int j = 0; j < 16; j++) {
				int k = i*16 + j;
				if (k < len) {
					char c = (char)((int)b[off+k]&0xff);
					if (c < 0x20) {
						sb2.append('.');
					} else {
						sb2.append(c);
					}
				} else {
					sb2.append('.');
				}
			}
			s = new String(sb2.toString().getBytes("8859_1"), charset);
			sb.append(s);
			sb.append('\n');
		}
		sb.append(len);
		sb.append('\n');
		return sb.toString();
	}
	
	/**
	 * 16진수값으로된 String을 int형으로 출력합니다.
	 * 
	 * @param str  String Hex 문자열.
	 * @return  10진수 형식으로 포맷팅된 int.
	 */
	public static int stringHexToInt(String str){
		byte[] b2 = new byte[str.length()];

		int temp = 0;
		for(int i=0;i<str.length();i++) {
			if(str.substring(i,i+1).equals("A") || str.substring(i,i+1).equals("a"))
				b2[i]=(byte)0x0A; 
			else if(str.substring(i,i+1).equals("B") || str.substring(i,i+1).equals("b"))
				b2[i]=(byte)0x0B; 
			else if(str.substring(i,i+1).equals("C") || str.substring(i,i+1).equals("c"))
				b2[i]=(byte)0x0C;
			else if(str.substring(i,i+1).equals("D") || str.substring(i,i+1).equals("d"))
				b2[i]=(byte)0x0D;
			else if(str.substring(i,i+1).equals("E") || str.substring(i,i+1).equals("e"))
				b2[i]=(byte)0x0E;
			else if(str.substring(i,i+1).equals("F") || str.substring(i,i+1).equals("f"))
				b2[i]=(byte)0x0F;
			else
				b2[i]=(byte)(Integer.parseInt(str.substring(i,i+1)) & 0x0F);

			temp = temp+(b2[i] << 4*(str.length()-(i+1)));
		}
		return temp;
	}
	
	public static String stringToBinary(String str){
		String binaryString = "";
		String temp = "";
		int off = 0;
		for(int i=0;i<str.length();i++){
			int value = StringUtil.stringHexToInt(str.substring(off, off+1));
			binaryString = Integer.toBinaryString(value);
			while(binaryString.length() % 4 != 0) {
				binaryString = "0" + binaryString;
			}
			
			temp = temp+binaryString;
			off++;
		}
		return temp;
	}

	/**
	 * MAP Version에 따라 DATETIME 필드 포맷이 변경됨(환승정보내역파일(교통칩)만 사용)
	 * 
	 * @param str  bit형 문자열.
	 * @return  yyyymmddhhnnss로 포맷팅한 문자열.
	 */
	public static String binaryToDateTime(String str){
		int len = 0;
		
		String temp = stringToBinary(str);
		
		String yy = 2000 + Integer.parseInt(temp.substring(len, len+7), 2)+"";
		len = len + 7;
		
		String mm = Integer.parseInt(temp.substring(len, len+4), 2) + "";
		while(mm.length() % 2 != 0) {
			mm = "0" + mm;
		}
		len = len + 4;

		String dd = Integer.parseInt(temp.substring(len, len+5), 2) + "";
		while(dd.length() % 2 != 0) {
			dd = "0" + dd;
		}
		len = len + 5;

		String hh = Integer.parseInt(temp.substring(len, len+5), 2) + "";
		while(hh.length() % 2 != 0) {
			hh = "0" + hh;
		}
		len = len + 5;

		String nn = Integer.parseInt(temp.substring(len, len+6), 2) + "";
		while(nn.length() % 2 != 0) {
			nn = "0" + nn;
		}
		len = len + 6;

		String ss = Integer.parseInt(temp.substring(len, len+6), 2) + "";
		while(ss.length() % 2 != 0) {
			ss = "0" + ss;
		}
		len = len + 6;
		
		return yy+mm+dd+hh+nn+ss;
	}
	
	/**
	 * 마이비에 따라 DATETIME 필드 포맷이 변경됨(환승정보내역파일(교통칩)만 사용)
	 * 
	 * @param str  bit형 문자열.
	 * @return  yyyymmddhhnnss로 포맷팅한 문자열.
	 */
	public static String binaryToDateTimeM(String str){
		int len = 0;
		
		String temp = stringToBinary(str);
		
		String yy = 2000 + Integer.parseInt(temp.substring(len, len+4), 2)+"";
		len = len + 4;
		
		String mm = Integer.parseInt(temp.substring(len, len+4), 2) + "";
		while(mm.length() % 2 != 0) {
			mm = "0" + mm;
		}
		len = len + 4;

		String dd = Integer.parseInt(temp.substring(len, len+5), 2) + "";
		while(dd.length() % 2 != 0) {
			dd = "0" + dd;
		}
		len = len + 5;

		String hh = Integer.parseInt(temp.substring(len, len+5), 2) + "";
		while(hh.length() % 2 != 0) {
			hh = "0" + hh;
		}
		len = len + 5;

		String nn = Integer.parseInt(temp.substring(len, len+6), 2) + "";
		while(nn.length() % 2 != 0) {
			nn = "0" + nn;
		}
		len = len + 6;
		
		return yy+mm+dd+hh+nn;
	}
	
	/**
	 * 
	 * @param value
	 * @return
	 */
	public static int parseInt(String value) {
		if (value==null || value.length()==0) return 0;
		String v = "";
		int radix = 10; /* default 10진수 */
		if (value.startsWith("0x") || value.startsWith("0X")) { /* 16진수 */
			radix = 16;
			v = value.substring(2);
		} else {
			radix = 10;
			v = value;
		}
		return Integer.parseInt(v, radix);
	}
	
	/**
	 * 
	 * @param value
	 * @return
	 */
	public static String valueOf(int value) {
		if (value==0) return "0";
		return String.valueOf(value);
	}
	
	/** 
	 * 입력 String 데이타를 주어진 class에 해당하는 Object를 생성하여
	 * 반환한다.
	 * @param value 입력값
	 * @param clazz 변환 Class
	 * @return object
	 */
	public static Object toObject(String value, Class clazz) {
		Object ret = null;
		
		if (value==null) return null;
		
		if (clazz==String.class) {
			ret = (new String(value)).trim();
		} else if (clazz==Short.class) {
			ret = new Short(value);
		} else if (clazz==Integer.class) {
			ret = new Integer(value);
		} else if (clazz==Byte.class) {
			ret = Byte.decode(value);
		}
		return ret;
	}
	
	public static String convertMDN(String mdn){
		String convertedMdn;
		
		if (mdn.length()==10)
			convertedMdn = mdn.substring(0,3) + "0" + mdn.substring(3);
		else
			convertedMdn = mdn;
		
		return convertedMdn;
	}
	
	public static String nvl(String src) {
		if (src==null || "".equals(src) || src.length() <=0) return "";
		return src;
	}

	public static String nvl(String src, String rtn) {
		if ( isEmpty(src) || "null".equals(src)) return rtn;
		return src;
	}

	public static int nvlInt(String src, int rtn) {
		if (isEmpty(src) || "null".equals(src)) {
			return rtn;
		} else {
			
			try {
				return Integer.parseInt(src);
			} catch (Exception e) {
				logger.error("nvlInt.e : " + e);
				return 0;
			}
		}
	}
	
	public static long nvlLong(String src, long rtn) {
		if (isEmpty(src) || "null".equals(src)) {
			return rtn;
		} else {
			
			try {
				return Long.parseLong(src);
			} catch (Exception e) {
				logger.error("nvlLong.e : " + e);
				return 0;
			}
		}
	}
	
	public static boolean nvlBoolean(String src, boolean rtn){
		if( isEmpty(src) || "null".equals(src)){
			return rtn;
		}
		
		boolean bRet = false;
		
		if( "N".equals(src)){
			bRet = false;
		}
		else if( "0".equals(src)){
			bRet = false;
		}
		else if( "Y".equals(src)){
			bRet = true;
		}
		else if( "1".equals(src)){
			bRet = true;
		}
		else{
			try{
				bRet = Boolean.parseBoolean(src);
			}
			catch(Exception e){
				logger.error("nvlBoolean.e : " + e);
			}
		}
		
		return bRet;
	}
	
	/*
	 * 주민 등록 번호 체크 
	 */
	public static boolean chkJuminNum(String num) {
		if (num == null ) {
			return false;
		} 
		try {
			int a = Integer.parseInt(num.substring(0,6));
			
			if (num.trim().length() == 7) { // 뒷번호
				if (num.charAt(0) != '1' && num.charAt(0) != '2')
					return false;
			} else if (num.trim().length() == 13) { //전체
				int b = Integer.parseInt(num.substring(6,13));
				
				if (num.charAt(6) != '1' && num.charAt(6) != '2')
					return false;
				int yy = Integer.parseInt(num.substring(0,2));
				int mm = Integer.parseInt(num.substring(2,4));
				if (mm < 1 || mm > 12)
					return false;
				int dd = Integer.parseInt(num.substring(4,6));
				int[] mmDD = {31,29,31,30,31,30,31,31,30,31,30,31};
				if (dd < 1 || dd > mmDD[mm-1])
					return false;
			} else 
				return false;
		} catch (Exception e) {
			logger.error("ERROR==>"+e.toString());
			return false;
		}
		return true;
	}
	
	public static String getJuminNumMasking(String num) {
		if (num==null || num.length() < 6) return num;
		else if (num.length()==6) return "******";
		else if (num.length()==7) return "*******";
		
		return (num.substring(0,6) + "*******");
	}
	
	/**
	 * 넘어온 문자열의 CharSet을 변경한다.
	 * KSC5601 -> 8859_1
	 * @param ko
	 * @return
	 */
	public static String ksc2Uni(String ko) {
		String en = null;
		if (ko==null) return null;
		try {
			en = new String(ko.getBytes("KSC5601"), "8859_1");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return en;
	}
	
	/**
	 * 넘어온 문자열의 CharSet을 변경한다.
	 * 8859_1 -> KSC5601
	 * @param en
	 * @return
	 */
	public static String uni2Ksc(String en) {
		String ko = null;
		if (en==null) return null;
		try {
			ko = new String(en.getBytes("8859_1"), "KSC5601");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return ko;
	}

	/**
	 * 입력 byte array값을 Hex String으로 변환한다.
	 * 
	 * @param value 입력 byte array
	 * @return Hex String
	 */
	public static String toHexString(byte[] value) {
		if (value==null) return null;
		
		StringBuffer sb = new StringBuffer();
		
		for (int i=0; i<value.length; i++) {
			int j = (value[i] >> 4) & 0xf;
			if (j <= 9)
				sb.append(j);
			else
				sb.append((char)(j+'A'-10));
			j = value[i]&0xf;
			if (j <= 9)
				sb.append(j);
			else
				sb.append((char)(j+'A'-10));
		};
		return sb.toString();
	}
	
	/**
	 * 입력 byte array값을 Hex String으로 변환한다.
	 * 
	 * @param value 입력 byte array
	 * @return Hex String
	 */
	public static byte[] parseHexString(String value) {
		
		if (value==null) return null;
		
		value = value.toUpperCase();
		int len = value.length();
		byte out[] = new byte[len/2];
		
		for(int i = 0; i < len/2; i++) {
			int j = i * 2;
			
			int high = 0;
			int low = 0;
			
			if (value.charAt(j) >= '0' && value.charAt(j)<='9')
				high = value.charAt(j) - '0';
			else if (value.charAt(j) >= 'A' && value.charAt(j)<='F')
				high = 10 + (value.charAt(j) - 'A');
			
			if (value.charAt(j) >= '0' && value.charAt(j+1)<='9')
				low = value.charAt(j+1) - '0';
			else if (value.charAt(j+1) >= 'A' && value.charAt(j+1)<='F')
				low = 10 + (value.charAt(j+1) - 'A');
			
			out[i] = (byte)(high * 16 + low);
		}
		return out;
	}
	
	public static int cutNextString(byte[] body, int sp, int ep) {
		int endIndex = sp + ep - 1;
		int cnt = 0;
		//System.out.println("--"+new String(body));
		while (endIndex >=0 && ((body[endIndex] & 0xff) > 128 && endIndex >= sp)) {
			cnt++;
			endIndex--;
			//System.out.println("cnt = "+cnt+", endIndex = "+endIndex);
		}
		// 한글 바이트 수가 홀수이면 짤렸다고 인식
		if (cnt%2 == 0)
			return ep;
		else 
			return ep - 1;
	}
	
	public static long getDateDiff(String begin, String end, String format) throws Exception {
		//logger.debug("s-"+begin+",e-"+end);
		long   datedif;

		try{
			SimpleDateFormat formatter = new SimpleDateFormat(format);
			Date beginDate = formatter.parse(begin);
			Date endDate = formatter.parse(end);
			long diff = endDate.getTime() - beginDate.getTime();
			long diffMin = diff / (60 * 1000);
			if (diffMin < 0)
				diffMin = diffMin * -1;
			return diffMin;
		} catch(Exception e){
			logger.error("날짜 데이터 처리 중 오류 발생:",e);
			throw new Exception(e);
		}
	}
	
	private static String addDelim(String date, String delim) {
		return date.substring(0,4)+delim+date.substring(4,6)+delim+date.substring(6,8);
	}

	private static String delDelim(String date) {
		return date.substring(0,4)+date.substring(5,7)+date.substring(8,10);
	}
	
	/**
	 * 날짜포맷팅. 
	 *
	 * @param  date  yyyyMMdd
	 */
	public static String getDate(String date, String delim) {
		if (date == null || date.length() < 8)
			return "";
		return addDelim(date, delim);
	}

	/**
	 * 날짜 형식 변환
	 *
	 * @param  String  날짜
	 * @param  String  날짜 형식
	 * @param  String  변환 날짜 형식
	 */
	public static String getDateTime(String date, String format, String rtnFormat) {
		SimpleDateFormat formatter = new SimpleDateFormat(format);
		Date newDate = null;
		try {
			newDate = formatter.parse(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		SimpleDateFormat rtnFormatter = new SimpleDateFormat(rtnFormat);
		return rtnFormatter.format(newDate);
	}
	
	/**
	 * 날짜사이 간격구하기
	 *
	 * @param  date  yyyyMMdd
	 */
	public static long getDifferDays(String startDate, String endDate){
		GregorianCalendar StartDate = getGregorianCalendar(startDate);
		GregorianCalendar EndDate = getGregorianCalendar(endDate);
		long difer = (EndDate.getTime().getTime() - StartDate.getTime().getTime()) / 86400000;
		return difer;
	}
	
	/**
	 * GregorianCalendar 객체를 반환함
	 *
	 * @param  date  yyyyMMdd
	 * @param  date  yyyyMMdd
	 */
	public static GregorianCalendar getGregorianCalendar(String yyyymmdd){
		int yyyy = Integer.parseInt(yyyymmdd.substring(0,4));
		int mm = Integer.parseInt(yyyymmdd.substring(4,6));
		int dd   = Integer.parseInt(yyyymmdd.substring(6));
		
		GregorianCalendar calendar = new GregorianCalendar(yyyy, mm - 1, dd, 0,0,0);
		return calendar;
	}

	/**
	 * 시간 포맷팅
	 * @param time
	 * @param delim
	 * @return
	 */
	public static String getTime(String time) {
		if (time == null || time.length() < 4)
			return "";
		if (time.length() < 6)
			return time.substring(0,2)+":"+time.substring(2,4);
		else
			return time.substring(0,2)+":"+time.substring(2,4)+":"+time.substring(4,6);
	}
	
	public static String getNumberCircle(int num) {
		if (num < 0 || num > 9)
			return "▶";
		
		String[] numIdx = {"①","②","③","④","⑤","⑥","⑦","⑧","⑨"};
		return numIdx[(num-1)];
	}
	
	/**
	 * 휴대폰번호 포맷
	 *
	 * @param  mdn    휴대전화번호
	 */
	public static String getMdnFmt(String mdn) {
		if (mdn == null) {
			return "";
		}
		
		if (mdn.length() < 10) {
			return mdn;
		}

		if(!mdn.startsWith("0",0)) {
			mdn = "0"+mdn;
		}

		if (mdn.length() == 11)
			return mdn.substring(0,3)+"-"+mdn.substring(3,7)+"-"+mdn.substring(7);
		else 
			return mdn.substring(0,3)+"-"+mdn.substring(3,6)+"-"+mdn.substring(6);
	}
	
	/**
	 * 빈문자 체크
	 * @param val
	 * @return
	 */
	public static boolean isEmpty(String val) {
		if (val == null || val.trim().length() == 0)
			return true;
		else
			return false;
	}
	
	/**
	 * null chekc "" 반환
	 * @param val
	 * @return
	 */
	public static String getNvl(String val){
		
		if (val == null || val.trim().length() == 0)
			return "";
		else
			return val.trim();
	}
	
	/**
	 * <pre>
	 * null Check
	 *  - in : Object
	 * @param obj
	 * @return 
	 * @exception 
	 * @date 2014. 7. 8. 오후 9:45:42
	 * @author adrra
	 * @비고
	 * 
	 * </pre>
	 */
	public static String getNvl(Object obj){
		
		if (obj == null)
			return "";
		else
			return ((String)obj).trim();
	}
	
	/**
	 * null check "NULL" 반환
	 * @param val
	 * @return
	 */
	public static String getNvlNULL(String val){
		
		if (val == null || val.trim().length() == 0)
			return "NULL";
		else
			return val.trim();
	}

	/**
	 * null chekc 입력값 반환
	 * @param val
	 * @return
	 */
	public static String getNvl(String val, String rtn){
		
		if (val == null || val.trim().length() == 0)
			return rtn;
		else
			return val.trim();
	}
	
	/**
	 * null chekc 입력값 반환
	 * @param val
	 * @return
	 */
	public static int getNvl(String val, int rtn){
		if (val == null || val.trim().length() == 0)
			return rtn;
		else{
			
			try{
				return Integer.parseInt(val.trim());
			}
			catch(Exception e){
				return rtn;
			}
		}
	}
	
	/**
	 * 금액 Masking #,###
	 * @param amt
	 * @return
	 */
	public static String getAmtFmtStr(String amt) {

		DecimalFormat df = new DecimalFormat("#,###");
		return new String(df.format(Integer.parseInt(amt)));
	}
	
	/**
	 * 금액 Masking #,###
	 * @param amt
	 * @return
	 */
	public static String getAmtFmt(int amt) {
		
		DecimalFormat df = new DecimalFormat("#,###");
		return new String(df.format(amt));
	}

	/**
	 * 금액 Masking #,###.##
	 * @param amt
	 * @return
	 */
	public static String getAmtFmt(double amt) {

		DecimalFormat df = new DecimalFormat("#,###.##");
		return new String(df.format(amt));
	}
	
	/**
	 * 카드번호 Masking 1234-5678-1234-5678
	 * @param cardNum
	 * @return
	 */
	public static String getCardNumFmt(String cardNum) {

		if (cardNum == null || cardNum.length() != 16)
			return cardNum;
		return cardNum.substring(0, 4) + "-" + cardNum.substring(4, 8) + "-"
		+ cardNum.substring(8, 12) + "-" + cardNum.substring(12, 16);
	}

	/**
	 * 카드번호 Masking 1234-****-****-5678
	 * @param cardNum
	 * @return
	 */
	public static String getCardNumMasking(String cardNum) {

		if (cardNum == null || cardNum.length() != 16)
			return cardNum;
		return cardNum.substring(0, 4) + "-" + "****" + "-" + "****" + "-"
		+ cardNum.substring(12, 16);
	}
	
	
	/**
	 * 뒤 4자리 마스킹
	 * @param phoneNm 010-1111-2222 또는 01011112222
	 * @return	010-1111-**** 또는 0101111****
	 */
	public static String getPhoneMasking(String phoneNm){
		return phoneNm.substring( 0, phoneNm.length()-4 ) + "****";
	}
	
	/**
	 * Split
	 * @param cmp
	 * @param str
	 * @return
	 */
	public static String[] stringToArray(String cmp, String str) {

		if (cmp == null || str == null)
			return null;
		java.util.StringTokenizer st = new java.util.StringTokenizer(str, cmp);
		String[] result = new String[st.countTokens()];

		for (int i = 0; i < result.length; i++) {
			result[i] = st.nextToken().trim();
		}

		return result;
	}
	
	/**
	 * toTokens
	 * @param str
	 * @param delim
	 * @return
	 */
	public static String[] toTokens(String str, String delim) {

		String[] tokenArr = null;

		if (str == null)
			return new String[0];
		if (str.indexOf(delim) == -1) {
			tokenArr = new String[1];
			tokenArr[0] = str;

			return tokenArr;
		}

		LinkedList linkedlist = new LinkedList();

		int pos = 0, startPos = 0;
		int srcLength = str.length();
		int tockenLength = delim.length();
		while (startPos < srcLength) {
			if (-1 == (pos = str.indexOf(delim, startPos)))
				break;

			linkedlist.add(str.substring(startPos, pos));
			startPos = pos + tockenLength;
		}
		if (startPos <= srcLength)
			linkedlist.add(str.substring(startPos));

		return (String[]) linkedlist.toArray(new String[0]);
	}

	/**
	 * 현재 날짜를 포멧에 맞게 반환
	 * @return
	 */
	public static String getCurrentDateFormat(String strFormat) {

		SimpleDateFormat format = new SimpleDateFormat(strFormat);
		return format.format(new Date());
	}

	/**
	 * 현재 yyyyMMdd 반환
	 * @return
	 */
	public static String getCurrentDate() {

		SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
		return format.format(new Date());
	}

	/**
	 * 현재 yyyyMM 반환
	 * @return
	 */
	public static String getCurrentMonth() {

		SimpleDateFormat format = new SimpleDateFormat("yyyyMM");
		return format.format(new Date());
	}

	/**
	 * 현재 HHmmss 반환
	 * @return
	 */
	public static String getCurrentTime() {

		SimpleDateFormat format = new SimpleDateFormat("HHmmss");
		return format.format(new Date());
	}

	/**
	 * 현재 yyyyMMddHHmmss 반환
	 * @return
	 */
	public static String getCurrentDateTime() {

		SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
		return format.format(new Date());
	}

	/**
	 * 현재 yyyyMMddHHmmss 반환
	 * @return
	 */
	public static String getCurrentDateTime2() {
		
		SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmssSSS");
		return format.format(new Date());
	}

	/**
	 * 현재일자에 년/월/일/시/분/초 를 더하거나 뺀 값을 yyyyMMdd 포맷으로 출력
	 * @param field
	 * @param gap
	 * @return
	 */
	public static String getDatewithGapCurrent(String field, int gap) {

		if (field == null || field.equals(""))
			return "";

		Calendar calendar = Calendar.getInstance();
		calendar.setTime(new Date()); // current time

		if(field.toUpperCase().equals("YEAR"))        calendar.add(Calendar.YEAR, gap);
		else if(field.toUpperCase().equals("MONTH"))  calendar.add(Calendar.MONTH, gap);
		else if(field.toUpperCase().equals("DATE"))   calendar.add(Calendar.DATE, gap);
		else if(field.toUpperCase().equals("HOUR"))   calendar.add(Calendar.HOUR, gap);
		else if(field.toUpperCase().equals("MINUTE")) calendar.add(Calendar.MINUTE, gap);
		else if(field.toUpperCase().equals("SECOND")) calendar.add(Calendar.SECOND, gap);

		java.text.SimpleDateFormat format = new java.text.SimpleDateFormat("yyyyMMdd");
		return format.format(new Date(calendar.getTimeInMillis()));
	}

	/**
	 * 현재일자에 년/월/일/시/분/초 를 더하거나 뺀 값을 입력한 포맷으로 출력
	 * @param field
	 * @param gap
	 * @return
	 */
	public static String getDatewithGapCurrent(String inFormat, String field, int gap) {
		
		if (field == null || field.equals(""))
			return "";
		
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(new Date()); // current time
		
		if(field.toUpperCase().equals("YEAR"))        calendar.add(Calendar.YEAR, gap);
		else if(field.toUpperCase().equals("MONTH"))  calendar.add(Calendar.MONTH, gap);
		else if(field.toUpperCase().equals("DATE"))   calendar.add(Calendar.DATE, gap);
		else if(field.toUpperCase().equals("HOUR"))   calendar.add(Calendar.HOUR, gap);
		else if(field.toUpperCase().equals("MINUTE")) calendar.add(Calendar.MINUTE, gap);
		else if(field.toUpperCase().equals("SECOND")) calendar.add(Calendar.SECOND, gap);
		
		java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(inFormat);
		return format.format(new Date(calendar.getTimeInMillis()));
	}
	
	/**
	 * 입력한일자에 년/월/일/시/분/초 를 더하거나 뺀 값을 yyyyMMdd 포맷으로 출력
	 * @param current 입력일자
	 * @param field 년/월/일/시/분/초
	 * @param gap
	 * @return
	 */
	public static String getDatewithGap(String current, String field, int gap) {

		if (field == null || field.equals("")) return null;
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
		Date currentDate = null;

		try {
			currentDate = dateFormat.parse(current);
		} catch (Exception e) {
			return null;
		}
		
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(currentDate) ;  //current time

		if(field.toUpperCase().equals("YEAR")) calendar.add(Calendar.YEAR, gap);
		else if(field.toUpperCase().equals("MONTH")) calendar.add(Calendar.MONTH, gap);
		else if(field.toUpperCase().equals("DATE")) calendar.add(Calendar.DATE, gap);
		else if(field.toUpperCase().equals("HOUR")) calendar.add(Calendar.HOUR, gap);
		else if(field.toUpperCase().equals("MINUTE")) calendar.add(Calendar.MINUTE, gap);
		else if(field.toUpperCase().equals("SECOND")) calendar.add(Calendar.SECOND, gap);

		return dateFormat.format(new Date(calendar.getTimeInMillis()));
		
	}
	
	/**
	 * 입력한일자에 년/월/일/시/분/초 를 더하거나 뺀 값을 원하는 포맷으로 출력
	 * @param current 입력일자
	 * @param format 입력/출력일자의 포맷
	 * @param field 년/월/일/시/분/초
	 * @param gap
	 * @return
	 */
	public static String getDatewithGap(String current, String format, String field, int gap) {

		if (field == null || field.equals("")) return "";
		
		SimpleDateFormat dateFormat = new SimpleDateFormat(format);
		Date currentDate = null;

		try {
			currentDate = dateFormat.parse(current);
		} catch (Exception e) {
			return null;
		}

		Calendar calendar = Calendar.getInstance();
		calendar.setTime(currentDate) ;  //current time

		if(field.toUpperCase().equals("YEAR")) calendar.add(Calendar.YEAR, gap);
		else if(field.toUpperCase().equals("MONTH")) calendar.add(Calendar.MONTH, gap);
		else if(field.toUpperCase().equals("DATE")) calendar.add(Calendar.DATE, gap);
		else if(field.toUpperCase().equals("HOUR")) calendar.add(Calendar.HOUR, gap);
		else if(field.toUpperCase().equals("MINUTE")) calendar.add(Calendar.MINUTE, gap);
		else if(field.toUpperCase().equals("SECOND")) calendar.add(Calendar.SECOND, gap);

		return dateFormat.format(new Date(calendar.getTimeInMillis()));
	}
	
	/**
	 * 입력한 날짜가 포함된 달의 이전달의 마지막 일자를 출력
	 * @param day YYYYMMDD
	 * @return DD
	 */
	public static String getDatewithGap(String day) {
		Calendar cal = Calendar.getInstance ( );
		String lastDay = null;
		try {
			cal.set ( Integer.parseInt ( day.substring(0,4) ), Integer.parseInt ( day.substring(4,6) ) -2, Integer.parseInt (day.substring(6,8)) );
			int lastDayTmp = (cal.getActualMaximum ( Calendar.DATE ));
			lastDay = Integer.toString(lastDayTmp);
		} catch (Exception e) {
			return null;
		}
		return lastDay;
	}

	/**
	 * 입력한 날짜가 포함된 달의 마지막 일자를 출력
	 * @param day YYYYMMDD
	 * @return DD
	 */
	public static String getMonthLastDate(String day) {

		Calendar cal = Calendar.getInstance ( );
		String lastDay = null;

		try {

			cal.set ( Integer.parseInt ( day.substring(0,4) ), Integer.parseInt ( day.substring(4,6) ) -1, Integer.parseInt (day.substring(6,8)) );
			int lastDayTmp = (cal.getActualMaximum ( Calendar.DATE ));
			lastDay = Integer.toString(lastDayTmp);

		} catch (Exception e) {
			return null;
		}
		return lastDay;
	}

	/**
	 * Base64 Char 중 Web에서 특수문자로 인식하는 부분을 변경한다.
	 * @param input
	 * @return
	 */
	public static String encodeWebBase64(String in) {
		if (in==null) return in;
		StringBuffer sb = new StringBuffer();
		for (int i = 0; i < in.length(); i++) {
			char c = in.charAt(i);
			if (c == '+')     c = '-';
			else if (c=='=')   c = '_';
			else if (c=='/')  c = '*';
			sb.append(c);
		}
		return sb.toString();
	}
	
	/**
	 * Base64 Decoder
	 * @param in
	 * @return
	 */
	public static String decodeWebBase64(String in) {
		if (in==null) return in;
		StringBuffer sb = new StringBuffer();
		for (int i = 0; i < in.length(); i++) {
			char c = in.charAt(i);
			if (c == '-')     c = '+';
			else if (c=='_')   c = '=';
			else if (c=='*')  c = '/';
			sb.append(c);
		}
		return sb.toString();
	}

	/**
	 * 우편번호 앞 2자리로 지역코드 반환
	 * @param zipcode
	 * @return
	 */
	public static String getAreaCode(String zipCode){
		
		String areaCode = "";
		
		if(zipCode == null || zipCode.length() < 2)
			areaCode = "99";

		String s = zipCode.substring(0, 2);
		
		if(s.equals("10") || s.equals("11") || s.equals("12") || s.equals("13") || s.equals("14") || s.equals("15")){
			areaCode = "01";
		} else if(s.equals("20") || s.equals("21") || s.equals("22") || s.equals("23") || s.equals("24") || s.equals("25") || s.equals("26") ){
			areaCode = "02";
		} else if(s.equals("30") ){
			areaCode = "03";
		} else if(s.equals("31") || s.equals("32") || s.equals("33") || s.equals("34") || s.equals("35") ){
			areaCode = "04";
		} else if(s.equals("36") || s.equals("37") || s.equals("38") || s.equals("39") ){
			areaCode = "05";
		} else if(s.equals("40") ){
			areaCode = "06";
		} else if(s.equals("41") || s.equals("42") || s.equals("43") || s.equals("44") || s.equals("45") || s.equals("46") || s.equals("47") || s.equals("48") ){
			areaCode = "07";
		} else if(s.equals("50") ){
			areaCode = "08";
		} else if(s.equals("51") || s.equals("52") || s.equals("53") || s.equals("54") || s.equals("55") ){
			areaCode = "09";
		} else if(s.equals("56") || s.equals("57") || s.equals("58") || s.equals("59") ){
			areaCode = "10";
		} else if(s.equals("60") || s.equals("61") ){
			areaCode = "11";
		} else if(s.equals("62") || s.equals("63") || s.equals("64") || s.equals("65") || s.equals("66") || s.equals("67") ){
			areaCode = "12";
		} else if(s.equals("68") ){
			areaCode = "13";
		} else if(s.equals("69") ){
			areaCode = "14";
		} else if(s.equals("70") || s.equals("71") || s.equals("72") ){
			areaCode = "15";
		} else if(s.equals("73") || s.equals("74") || s.equals("75") || s.equals("76") || s.equals("77") || s.equals("78") || s.equals("79") ){
			areaCode = "16";
		} else{
			areaCode = "99";
		}
		
		return areaCode;
	}
	
	/**
	 * LPAD
	 * @param str 입력 및 반환
	 * @param addStr add할 문자
	 * @param len 전체 길이
	 * @return
	 */
	public static String getLpad(String str, String addStr, int len){
		
		if(addStr == null || addStr.length() == 0 )
			return str;

		if(str == null)  str = "";
		
		if(len < str.length()) return str;

		int tmpLen = len - str.length();
		
		for(int i = 0; i < tmpLen; i++)
			str = addStr + str;
		
		return str;
	}

	/**
	 * 문자열에서 숫자만 반환
	 * @param input
	 * @return
	 */
	public static String getDigit(String input){
		
		if(input == null || input.trim().length() == 0){
			return "";
		}
		
		StringBuffer sb = new StringBuffer();
		int length = input.length();
		
		for(int i = 0; i < length; i++){
			char curChar = input.charAt(i);
			if(Character.isDigit(curChar))
				sb.append(curChar);
		}
		return sb.toString();
	}
	
	/**
	 * 지점SEQ를 2자리 PIN Prefix로 변환
	 * 0 ~ 99 :  숫자를 그대로 두자리수로 변환
	 * 100 ~  :  첫자리:   a ~ z   (26개)
	 *           두번째:  0~9a~z   (36개)
	 */
	public static String toMrhstPinPrefix(int mrhstSeq) {
		if (mrhstSeq < 100) {
			return StringUtil.format(mrhstSeq, 2);
		}

		int quot = (mrhstSeq - 100) / 36;
		int div = ((mrhstSeq - 100) % 36);
		
		String prefix = (char)('a' + quot) + "";
		if (div >= 10) // a~z로 표시
			prefix += (char)('a' + (div - 10));
		else // 0~9로 표시
			prefix += (char)('0' + div);
		
		return prefix;
	}
	
	/**
	 * PIN prefix를 지점 SEQ로 변환
	 * 첫자리가 숫자인 경우: int로 그냥 변환
	 * 첫자리가 문자인 경우: 100부터 아래 규칙으로 변환
	 *   - 첫자리:   a ~ z      (26개)
	 *   - 두번째:   0~9a~z   (36개)
	 * @return
	 */
	public static int toMrhstSeq(String mrhstPinPrefix) {
		if (mrhstPinPrefix==null || mrhstPinPrefix.length()!=2)
			return 0;
		
		char firstChar = mrhstPinPrefix.charAt(0);
		char secondChar = mrhstPinPrefix.charAt(1);
		
		if (firstChar <= '9') { //100보다 작은 수
			return StringUtil.parseInt(mrhstPinPrefix);
		}
		
		//100이상인 경우
		int seq = (firstChar - 'a') * 36;
		if (secondChar <= '9')  //0~9인 경우
			seq += (secondChar - '0');
		else //a~z 인 경우
			seq += (10 + (secondChar - 'a'));
		
		return (100+seq);
	}
	
	/**
	 * 주어진 길이를 기준으로 문자열을 split한다.
	 * 한글 처리를 위해 KSC5601 encoding을 사용하며 중간에 한글이 잘리는 경우
	 * 그 전까지만 잘라낸다.
	 * @param src
	 * @param splitSize
	 * @return
	 */
	public static String[] splitBySize(String src, int splitSize) {

		if (src == null || splitSize <= 0)
			return new String[0];

		List<String> resultList = new ArrayList<String>();

		byte[] srcBytes = null;
		try {
			srcBytes = src.getBytes("KSC5601");
		} catch (Exception e) {
			return new String[0];
		}

		int srcSize = srcBytes.length;

		// src의 길이가 split 길이보다 작거나 같은 경우 원본만 return
		if (splitSize >= srcSize) {
			resultList.add(src);
			String[] result = new String[resultList.size()];
			return (String[]) resultList.toArray(result);
		}

		// split길이로 원본 사이즈를 잘라가면서 strig array에 각 split된 string을 만들어 넣음
		// 한글인 경우 중간에 잘리는 경우 데이타가 잘리지 않도록 그 앞에서 자름
		byte[] dstBytes = new byte[splitSize];

		int hanCnt = 0;
		int dstOff = 0;
		String splitStr = null;
		for (int i = 0; i < srcSize; i++) {
			dstBytes[dstOff] = srcBytes[i];

			if ((dstBytes[dstOff] & 0xFF) > 0x7F)
				hanCnt++;
			if ((dstOff + 1) == splitSize) {
				if ((splitSize > 1) && ((hanCnt % 2) != 0)
						&& ((dstBytes[dstOff] & 0xFF) > 0x7F)) {
					dstOff--;
					i--;
				}
				try {
					splitStr = new String(dstBytes, 0, dstOff + 1, "KSC5601");
				} catch (Exception e) {
					return new String[0];
				}
				resultList.add(splitStr);
				hanCnt = 0;
				dstOff = 0;
			} else {
				dstOff++;
			}
		}
		if (dstOff > 0) {
			try {
				splitStr = new String(dstBytes, 0, dstOff, "KSC5601");
			} catch (Exception e) {
				return new String[0];
			}
			resultList.add(splitStr);
		}

		String[] result = new String[resultList.size()];
		return (String[]) resultList.toArray(result);
	}
	
	/**
	 * 랜덤번호생성
	 * @param len
	 * @return
	 */
	public static String generateKey(int len) {

		Random r = new Random();
		r.setSeed(new Date().getTime());
		StringBuffer key = new StringBuffer();

		while (key.length() < len) {
			int iKey = Math.abs(r.nextInt() % 74) + 48;
			if (iKey >= 48 && iKey <= 57)
				key.append((char) iKey);
		}
		return key.toString();
	}
	
	public static void main(String[] args) {
		String num = StringUtil.generateKey(6);
		System.out.print(num);
	}
	
	/**
	 * 반올림/절상/절하
	 * @param strMode  수식
	 * @param nCalcVal 처리할 값(소수점 이하 데이터 포함)
	 * @param nDigit   연산 기준 자릿수(오라클의 ROUND함수 자릿수 기준)
	 *                 -2:십단위, -1:원단위, 0:소수점 1자리
	 *                 1:소수점 2자리, 2:소수점 3자리, 3:소수점 4자리, 4:소수점 5자리 처리
	 * @return
	 */
	public static String calcMath(String strMode, double nCalcVal, int nDigit) {

		if(strMode.equals("ROUND")) {
			//반올림
			if(nDigit < 0) {
				nDigit = -(nDigit);
				nCalcVal = Math.round(nCalcVal / Math.pow(10, nDigit)) * Math.pow(10, nDigit);
			} else {
				nCalcVal = Math.round(nCalcVal * Math.pow(10, nDigit)) / Math.pow(10, nDigit);
			}
		} else if(strMode.equals("CEIL")) {
			//절상
			if(nDigit < 0) {
				nDigit = -(nDigit);
				nCalcVal = Math.ceil(nCalcVal / Math.pow(10, nDigit)) * Math.pow(10, nDigit);
			} else {
				nCalcVal = Math.ceil(nCalcVal * Math.pow(10, nDigit)) / Math.pow(10, nDigit);
			}
		} else if(strMode.equals("FLOOR")) {
			//절하(절삭)
			if(nDigit < 0) {
				nDigit = -(nDigit);
				nCalcVal = Math.floor(nCalcVal / Math.pow(10, nDigit)) * Math.pow(10, nDigit);
			} else {
				nCalcVal = Math.floor(nCalcVal * Math.pow(10, nDigit)) / Math.pow(10, nDigit);
			}
		} else {                        //그대로(무조건 소수점 첫째 자리에서 반올림)
			nCalcVal = Math.round(nCalcVal);
		}
		return String.valueOf(nCalcVal);
	}
	
	/**
	 * <pre>
	 * 문자열 반대로 뒤집기
	 * 전달받은 문자열을 반데로 뒤집는다.
	 * @param strMode
	 * @param nCalcVal
	 * @param nDigit
	 * @return 
	 * @exception 
	 * @date 2015. 6. 10. 오전 10:03:47
	 * @author N.J.Kim
	 * @비고
	 * 
	 * </pre>
	 */
	public static String reverseString (String str) {

		String tmpSESSION = "";
		str = nvl(str);

		for (int i = (str.length() - 1); i >= 0; i--) {
			tmpSESSION += str.charAt(i);
		}

		return tmpSESSION;
	}
	
	/**
	 * <pre>
	 * 지정한 바이트 수 만큼 문자열 자르기
	 * 마지막이 한글인 경우 깨지지 않게..
	 * @param raw
	 * @param len
	 * @param encoding
	 * @return
	 * @date 2015. 8. 31. 오후 2:35:56
	 * @author S.B.LEE
	 * @see com.ssocio.sharing.cmmn.util
	 * </pre>
	 */
	public static String[] parseStringByBytes(String raw, int len,  String encoding){
		
		if(raw == null) return null;
		String[] ary = null;
		try {
			
			byte[] rawBytes = raw.getBytes(encoding);
			int rawLength = rawBytes.length;
			int index = 0;
			int minus_byte_num = 0;
			int offset = 0;
			int hangul_byte_num = encoding.equals("UTF-8") ? 3 : 2;
			if(rawLength > len){
				int aryLength = (rawLength/len) + (rawLength%len != 0 ? 1 : 0);
				ary = new String[aryLength];
				for(int i=0;i<aryLength;i++){
					minus_byte_num = 0;
					offset = len;
					if(index + offset > rawBytes.length){
						offset = rawBytes.length - index;
					}
					for(int j=0; j<offset; j++){
						if(((int)rawBytes[index+j] & 0x80) != 0){
							minus_byte_num++;
						}
					}
					if(minus_byte_num % hangul_byte_num != 0){
						offset -= minus_byte_num % hangul_byte_num;
					}
					ary[i] = new String(rawBytes, index, offset, encoding);
					index += offset;
				}
				
			} else {
				ary = new String[]{raw};
			}
			
		} catch(Exception e){
			e.printStackTrace();
		}
		
		return ary;
		
	}  
	
	public static String replaceEmptyString(String src, String limiter){
		return limiter.equals(src) == true ? "" : src;
	}
	
	
	public static boolean isValidUTF8(String  myString) 
	{
		
		byte[] bytes = null;
	    try {
	    	bytes = myString.getBytes("UTF-8");
	        Charset.availableCharsets().get("UTF-8").newDecoder().decode(ByteBuffer.wrap(bytes));
	    } catch (CharacterCodingException | UnsupportedEncodingException e) {
	        return false;
	    }
	 
	    return true;
	}
	
	public static String convertUTF8(String msg)
	{
		try {
			return new String( msg.getBytes("euc-kr"), "utf-8");
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}	
	
	
	public static String str2hex(String msg)
	{
		return  toHexString(msg.getBytes());
	}
	
	public static String hex2str(String msg)
	{
		return  new String (  parseHexString( msg) );
	}
	
	
}
